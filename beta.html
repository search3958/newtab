<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>リンク集</title>
  <script>
if ("paintWorklet" in CSS) {
  const workletCode = `
    const drawSquircle=(ctx,geom,radii,smooth,lineWidth,color)=>{const defaultFill=color;const lineWidthOffset=lineWidth/2;ctx.beginPath();ctx.lineTo(radii[0],lineWidthOffset);ctx.lineTo(geom.width-radii[1],lineWidthOffset);ctx.bezierCurveTo(geom.width-radii[1]/smooth,lineWidthOffset,geom.width-lineWidthOffset,radii[1]/smooth,geom.width-lineWidthOffset,radii[1]);ctx.lineTo(geom.width-lineWidthOffset,geom.height-radii[2]);ctx.bezierCurveTo(geom.width-lineWidthOffset,geom.height-radii[2]/smooth,geom.width-radii[2]/smooth,geom.height-lineWidthOffset,geom.width-radii[2],geom.height-lineWidthOffset);ctx.lineTo(radii[3],geom.height-lineWidthOffset);ctx.bezierCurveTo(radii[3]/smooth,geom.height-lineWidthOffset,lineWidthOffset,geom.height-radii[3]/smooth,lineWidthOffset,geom.height-radii[3]);ctx.lineTo(lineWidthOffset,radii[0]);ctx.bezierCurveTo(lineWidthOffset,radii[0]/smooth,radii[0]/smooth,lineWidthOffset,radii[0],lineWidthOffset);ctx.closePath();if(lineWidth){ctx.strokeStyle=defaultFill;ctx.lineWidth=lineWidth;ctx.stroke()}else{ctx.fillStyle=defaultFill;ctx.fill()}};class SquircleClass{static get contextOptions(){return{alpha:true}}static get inputProperties(){return["--squircle-radius","--squircle-radius-top-left","--squircle-radius-top-right","--squircle-radius-bottom-right","--squircle-radius-bottom-left","--squircle-smooth","--squircle-outline","--squircle-fill"]}paint(ctx,geom,properties){const smoothRatio=10;const distanceRatio=1.8;const squircleSmooth=parseFloat(properties.get("--squircle-smooth")*smoothRatio);const individualRadiiProps=SquircleClass.inputProperties.slice(1,5);let squircleRadii=individualRadiiProps.map(prop=>{const value=properties.get(prop);return value?parseInt(value,10)*distanceRatio:NaN});let shorthand_R;if(squircleRadii.some(isNaN)){const radiusRegex=/([0-9]+[a-z%]*)/g;const radius_shorthand=properties.get("--squircle-radius").toString();const matches=radius_shorthand.match(radiusRegex);if(matches){shorthand_R=matches.map(val=>parseInt(val,10)*distanceRatio);while(shorthand_R.length<4){if(shorthand_R.length===1){shorthand_R.push(shorthand_R[0])}else if(shorthand_R.length===2){shorthand_R=[shorthand_R[0],shorthand_R[1],shorthand_R[0],shorthand_R[1]]}else if(shorthand_R.length===3){shorthand_R=[shorthand_R[0],shorthand_R[1],shorthand_R[2],shorthand_R[1]]}}}else{const defaultRadius=squircleRadii.every(isNaN)?8*distanceRatio:0;shorthand_R=[defaultRadius,defaultRadius,defaultRadius,defaultRadius]}}squircleRadii=squircleRadii.map((val,i)=>isNaN(val)?shorthand_R[i]:val);const squrcleOutline=parseFloat(properties.get("--squircle-outline"),10);const squrcleColor=properties.get("--squircle-fill").toString();const isSmooth=()=>{if(typeof properties.get("--squircle-smooth")[0]!=="undefined"){if(squircleSmooth===0){return 1}return squircleSmooth}else{return 10}};const isOutline=()=>{if(squrcleOutline){return squrcleOutline}else{return 0}};const isColor=()=>{if(squrcleColor){return squrcleColor}else{return"#f45"}};const maxRadius=Math.max(...squircleRadii);if(maxRadius<geom.width/2&&maxRadius<geom.height/2){drawSquircle(ctx,geom,squircleRadii,isSmooth(),isOutline(),isColor())}else{const minRadius=Math.min(geom.width/2,geom.height/2);drawSquircle(ctx,geom,squircleRadii.map(()=>minRadius),isSmooth(),isOutline(),isColor())}}}if(typeof registerPaint!=="undefined"){registerPaint("squircle",SquircleClass)}
  `;
  const blob = new Blob([workletCode], { type: 'application/javascript' });
  const blobURL = URL.createObjectURL(blob);
  CSS.paintWorklet.addModule(blobURL);
}
</script>
  <style>
    :root{
      --iconbg:#fff9;
      --glass-shadow: #fffb 0px 1.5px 3px inset,#fff7 0px -1.5px 3px inset;
    }
    body {
      margin: 0;
      font-family: sans-serif;
      background: url('https://search3958.github.io/newtab/bgimg/3958Glass4.webp') no-repeat center center fixed;
      background-size: cover;
    }



    @keyframes bg-blur {
      from {
        backdrop-filter:blur(0px) brightness(100%);
      }
      to {
        backdrop-filter:blur(24px) brightness(106%);
      }
    }


    body:before{
      content:" ";
      position:fixed;
      backdrop-filter:blur(24px) brightness(103%);
      height:100%;
      width:100%;


      animation: bg-blur cubic-bezier(.5,0,0,1) both;
      animation-timeline: view();
animation-range: entry 100% entry 130%;
    }
    * { scrollbar-width: none; }
    *::-webkit-scrollbar { display: none; }


    main#links-container {
        display: flex;
        flex-direction: column;
        align-content: center;
        align-items: center;
        
    }

    @keyframes main-fade-anm {
      from {
        opacity:0;
      top: 0vh;
      filter:blur(10px);
        pointer-events:none;
      }
      to {
        opacity:1;
      top: 0vh;
      filter:blur(0px);
      pointer-events:unset;
      }
    }


    #links-container {
      opacity: 0;
      transition: opacity 0.2s;
      padding-bottom:300px;
      position:relative;
      padding-top:50vh;

      animation: main-fade-anm cubic-bezier(.5,0,0,.7) both;
      animation-timeline: view();
      animation-range: entry 100% entry 150%;

    }
    #links-container.visible {
      opacity: 1;
    }

    .category {
      margin-bottom: 20px;
      gap: 16px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      flex-direction: row;
      max-width:875px;

      animation: size-anm-a cubic-bezier(.41,0,0,1) both;
      animation-timeline: view();
      animation-range: contain -30% contain 20%;
    
}
    .category-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; width:100vw; text-align:center;}


    @keyframes size-anm-a {
      from {
        filter:blur(5px);
      }
      to {
        filter:blur(0px);
      }
    }



    .appicon-bg {
      display: block;
      padding: 0px;
      border-radius: 8px;
      text-align: center;
      width: 100px;
      position:relative;
      height:105px;
      width:105px;
      mask-image:url('data:image/svg+xml;utf8,<svg width="105" height="105" viewBox="0 0 110 110" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 55C0 29.573 0 16.8595 7.65351 8.76409C8.01325 8.38358 8.38358 8.01325 8.76409 7.65351C16.8595 0 29.573 0 55 0V0C80.427 0 93.1405 0 101.236 7.65351C101.616 8.01325 101.987 8.38358 102.346 8.76409C110 16.8595 110 29.573 110 55V55C110 80.427 110 93.1405 102.346 101.236C101.987 101.616 101.616 101.987 101.236 102.346C93.1405 110 80.427 110 55 110V110C29.573 110 16.8595 110 8.76409 102.346C8.38358 101.987 8.01325 101.616 7.65351 101.236C0 93.1405 0 80.427 0 55V55Z" fill="black"/></svg>');
    }
    .appicon-img {
      height:95px;
      width:95px;
      margin:5px;
      object-fit: cover;
      border-radius: 4px;
    }
    .appicon-label {
      font-size: 12px;
      margin-top: 4px;
      position:absolute;
      bottom:10px;
      left:10px;
      backdrop-filter: brightness(100%);
      padding:4px;
      background:#fff0;
      border-radius:10px;
      scale:0.9;
      color:#0000;
      transition:all 0.5s cubic-bezier(.34,.24,0,1);
      max-width: 75px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      opacity:0;
    }
    
    .appicon-bg:hover>.appicon-label {
      backdrop-filter: brightness(160%) blur(8px);
      background:#fff6;
      scale:0.999;
      color:#000f;
      opacity:1;
    }

    @keyframes search-anm {
      from {
        scale:1;
      bottom:15px;
      }
      to {
        scale:0.3 0.4;
      bottom:-70px;
      }
    }
    .search-box{
      position:fixed;
      left:calc(50vw - 90px);
      height:50px;
      z-index:100;
      border-radius:25px;
      width:180px;

      animation: search-anm cubic-bezier(.6,0,0,1) both;
      animation-timeline: view();
      animation-range: contain 0% contain 70%;

    }

    .search-box-in{
      position:absolute;
      width:100%;
      height:100%;
      z-index:1001;
      border-radius:24px;
      backdrop-filter:blur(4px) brightness(130%);
      background:#fff9;
      box-shadow:var(--glass-shadow);
      display: flex;
      align-items: center;
      justify-content: space-around;


    mask-image: paint(squircle);
    --squircle-radius: 25px;
    --squircle-smooth: 0.27;
    }

    .any-box{
      position:fixed;
      left:calc(50vw - 150px);
      bottom:80px;
      height:110px;
      z-index:100;
      border-radius:36px;
      width:300px;
    }


    .any-box-in{
      position:absolute;
      width:100%;
      height:100%;
      z-index:1001;
      border-radius:27px;
      backdrop-filter:blur(4px) brightness(130%);
      background:#fff9;
      box-shadow:var(--glass-shadow);
      display: flex;
      align-items: center;
      justify-content: space-around;
    mask-image: paint(squircle);
    --squircle-radius: 20px;
    --squircle-smooth: 0.4;
    }
  </style>
</head>
<body>

  <div class="search-box liquid-glass">
   <div class="search-box-in">
    なんでも検索
   </div>
  </div>


  <div class="any-box liquid-glass">
   <div class="any-box-in">
    なんでも検索
   </div>
  </div>
  <main id="links-container">

  </main>

  <script src="https://unpkg.com/fflate@0.8.2/umd/index.js"></script>
  <script>
    const getFileName = (path) => path.split('/').pop();

    const loadZip = async (url) => {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('ZIP fetch failed');
        const buffer = await response.arrayBuffer();
        const files = fflate.unzipSync(new Uint8Array(buffer));
        const imageMap = {};
        for (const [path, data] of Object.entries(files)) {
          const fileName = getFileName(path);
          const blob = new Blob([data.buffer], { type: 'image/webp' });
          imageMap[fileName] = URL.createObjectURL(blob);
        }
        return imageMap;
      } catch (err) {
        console.error('loadZip error', err);
        return {};
      }
    };

    const loadData = async () => {
      try {
        const zipUrl = 'https://search3958.github.io/newtab/lsr/icons-4-5.zip';
        const imageMap = await loadZip(zipUrl);

        const jsonUrl = 'https://search3958.github.io/newtab/links.json';
        const res = await fetch(jsonUrl);
        if (!res.ok) throw new Error('links.json fetch failed');
        const data = await res.json();

        const container = document.getElementById('links-container');

        (data.categories || []).forEach(category => {
          const categoryDiv = document.createElement('div');
          categoryDiv.className = 'category';

          const title = document.createElement('h2');
          title.className = 'category-title';
          title.textContent = category.title || '無題';
          categoryDiv.appendChild(title);

          (category.links || []).forEach(link => {
            const a = document.createElement('a');
            a.href = link.url || '#';
            a.target = '_blank';
            a.rel = 'noopener noreferrer';

            const iconDiv = document.createElement('div');
            iconDiv.className = 'appicon-bg';
            if (link.bg) iconDiv.style.background = link.bg;

            const img = document.createElement('img');
            img.className = 'appicon-img';
            const src = imageMap[link.icon];
            img.alt = link.name || '';
            img.src = src || link.icon || '';

            const label = document.createElement('div');
            label.className = 'appicon-label';
            label.textContent = link.name || '';

            iconDiv.appendChild(img);
            iconDiv.appendChild(label);
            a.appendChild(iconDiv);
            categoryDiv.appendChild(a);
          });

          container.appendChild(categoryDiv);
        });

        // スクロール位置に応じて透明度切り替え
        const checkVisibility = () => {
          const rect = container.getBoundingClientRect();
          if (rect.top <= 0) {
            container.classList.add('visible');
          } else {
            container.classList.remove('visible');
          }
        };

        window.addEventListener('scroll', checkVisibility);
        checkVisibility();
      } catch (err) {
        console.error('loadData error', err);
      }
    };

    loadData();
  </script>

  <script>// Liquid Glass JS
    function createBorderMask(w,h,radius,border){const innerW = w - border * 2;const innerH = h - border * 2;const innerRadius = Math.max(radius - border,0);const svg = ` <svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}"> <defs> <mask id="m"> <rect width="${w}" height="${h}" rx="${radius}" ry="${radius}" fill="white"/> <rect x="${border}" y="${border}" width="${innerW}" height="${innerH}" rx="${innerRadius}" ry="${innerRadius}" fill="black"/> </mask> </defs> <rect width="${w}" height="${h}" mask="url(#m)" /> </svg> `;return `url("data:image/svg+xml,${encodeURIComponent(svg)}")`;}function applyLiquidGlassEffect(container){const outerCount = 20;const outerStep = 2;const borderThickness = 6;const masks = [];function updateMasks(){masks.forEach(mask => mask.remove());masks.length = 0;const computedStyle = window.getComputedStyle(container);const width = parseFloat(computedStyle.width);const height = parseFloat(computedStyle.height);const borderRadius = parseFloat(computedStyle.borderRadius)|| 0;for(let i = 0;i < outerCount;i++){const inset = i * outerStep;const normalizedPosition =(outerCount - i)/ outerCount;const blur = Math.pow(normalizedPosition,3.5)* 40;const currentWidth = width - inset * 2;const currentHeight = height - inset * 2;const currentRadius = Math.max(borderRadius - inset,0);if(currentWidth <= 0 || currentHeight <= 0)continue;const mask = document.createElement('div');mask.className = 'mask';mask.style.position = 'absolute';mask.style.inset = `${inset}px`;mask.style.width = `${currentWidth}px`;mask.style.height = `${currentHeight}px`;mask.style.borderRadius = `${currentRadius}px`;mask.style.backdropFilter = `blur(${blur}px)`;mask.style.webkitBackdropFilter = `blur(${blur}px)`;mask.style.pointerEvents = 'none';mask.style.zIndex = `${outerCount - i}`;mask.style.mask = createBorderMask(currentWidth,currentHeight,currentRadius,borderThickness);mask.style.webkitMask = createBorderMask(currentWidth,currentHeight,currentRadius,borderThickness);container.appendChild(mask);masks.push(mask);}}updateMasks();const resizeObserver = new ResizeObserver(()=>{updateMasks();});resizeObserver.observe(container);container._resizeObserver = resizeObserver;}document.querySelectorAll('.liquid-glass').forEach(el =>{applyLiquidGlassEffect(el);});
  </script>
</body>
</html>
