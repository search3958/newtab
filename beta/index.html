<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Custom Scroll Engine — Minimal</title>
<style>
:root{--bg:#0f172a;--fg:#e6eef8;--accent:#7dd3fc;--scrollbar-width:10px}
html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Roboto,Segoe UI}
.main-container-3958{display:flex;flex-direction:column;align-items:center;padding:20px}
.scroll-viewport{position:relative;width:720px;height:420px;border-radius:12px;overflow:hidden;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));box-shadow:0 8px 30px rgba(2,6,23,0.6)}
.scroll-content{position:absolute;left:0;top:0;right:0;will-change:transform}
.scroll-content.transitioning{transition:transform 360ms cubic-bezier(0,0,0,1)}
.content-padding{padding:20px}
.scrollbar{position:absolute;right:6px;top:6px;bottom:6px;width:var(--scrollbar-width);pointer-events:none}
.scrollbar-track{position:absolute;inset:0;border-radius:8px;background:rgba(255,255,255,0.02)}
.scrollbar-thumb{position:absolute;right:0;width:100%;border-radius:8px;background:var(--accent);transform-origin:center top;box-shadow:0 2px 6px rgba(0,0,0,0.5);pointer-events:auto}
.overscroll-glow{position:absolute;left:0;right:0;height:24px;background:linear-gradient(180deg, rgba(125,211,252,0.12), transparent);pointer-events:none;opacity:0;transition:opacity 200ms cubic-bezier(0,0,0,1)}
.overscroll-top{top:0}
.overscroll-bottom{bottom:0;transform:rotate(180deg)}
button{background:var(--accent);border:none;padding:8px 10px;border-radius:8px;cursor:pointer}
button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06)}
</style>
</head>
<body>
<div class="main-container-3958">
  <!-- controls intentionally removed for a minimal build -->
  <div class="scroll-viewport" tabindex="0" id="vp">
    <div class="overscroll-glow overscroll-top" id="os-top" aria-hidden="true"></div>
    <div class="overscroll-glow overscroll-bottom" id="os-bottom" aria-hidden="true"></div>

    <div class="scroll-content" id="content">
      <div class="content-padding" id="inner">
        <h1>Custom Scroll — Minimal</h1>
        <div id="sample" aria-hidden="false"></div>
      </div>
    </div>

    <div class="scrollbar" aria-hidden="true">
      <div class="scrollbar-track"></div>
      <div class="scrollbar-thumb" id="thumb"></div>
    </div>
  </div>
</div>

<script>
// small, defensive utilities
const $ = (selector, root = document) => {
  try {
    return root.querySelector(selector);
  } catch (err) {
    console.error('Query selector error for', selector, err);
    return null;
  }
};
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const rubber = (d, dim) => { const c = 0.55; return (d * c * dim) / (dim + c * d); };

class Scroller {
  constructor({ viewport, content, thumb, overscroll = true } = {}) {
    // allow passing either element or id string
    if (typeof viewport === 'string') viewport = document.getElementById(viewport);
    if (typeof content === 'string') content = document.getElementById(content);

    if (!viewport) { console.error('Scroller: missing viewport element'); return; }
    if (!content)  { console.error('Scroller: missing content element'); return; }

    this.vp = viewport;
    this.content = content;
    this.thumb = thumb || null;
    this.overscroll = Boolean(overscroll);

    // dims & state
    this.containerH = 0;
    this.contentH = 0;
    this.max = 0;
    this.y = 0;
    this.v = 0;
    this.isDown = false;
    this.lastY = 0;
    this.lastTime = performance.now();
    this.raf = 0;
    this.lastRenderY = null;
    this._pending = undefined;

    // overscroll elements (may be null — check everywhere)
    this.osTop = $('#os-top', this.vp);
    this.osBottom = $('#os-bottom', this.vp);

    // bind handlers as stable references for add/remove
    this.onDown = e => this._onDown(e);
    this.onMove = e => this._onMove(e);
    this.onUp = e => this._onUp(e);
    this.onWheel = e => this._onWheel(e);
    this.onKey = e => this._onKey(e);
    this.onResize = () => this._measure();
    this.onTrans = e => this._onTrans(e);

    // initialize
    this._measure();
    this._addListeners();
    this.raf = requestAnimationFrame(t => this._tick(t));
    console.log('Scroller initialized', { viewport: this.vp, content: this.content });
  }

  _measure() {
    this.containerH = this.vp.clientHeight;
    // fallback to scrollHeight or content bounding
    this.contentH = this.content.scrollHeight || this.content.getBoundingClientRect().height || 0;
    this.max = Math.max(0, this.contentH - this.containerH);
    // clamp y within soft overscroll bounds
    this.y = clamp(this.y, -this.containerH * 0.5, this.max + this.containerH * 0.5);
    this._render(true);
    this._updateThumb();
  }

  _addListeners() {
    try {
      this.vp.addEventListener('pointerdown', this.onDown, { passive: false });
      window.addEventListener('pointermove', this.onMove, { passive: false });
      window.addEventListener('pointerup', this.onUp, { passive: false });
      this.vp.addEventListener('wheel', this.onWheel, { passive: false });
      this.vp.addEventListener('keydown', this.onKey);
      window.addEventListener('resize', this.onResize);
      this.content.addEventListener('transitionend', this.onTrans);
    } catch (err) {
      console.error('Scroller: failed to add listeners', err);
    }
  }

  _onDown(e) {
    if (e.pointerType === 'mouse' && e.button !== 0) return;
    this.isDown = true;
    this.lastY = e.clientY;
    this.v = 0;
    this._stopTransition();
    try {
      if (this.vp.setPointerCapture) this.vp.setPointerCapture(e.pointerId);
    } catch (err) {
      // non-fatal
      console.warn('setPointerCapture failed', err);
    }
    e.preventDefault();
  }

  _onMove(e) {
    if (!this.isDown) return;
    const dy = e.clientY - this.lastY;
    this.lastY = e.clientY;
    const next = this.y - dy;

    if (next < 0) {
      if (this.overscroll) {
        const o = -next;
        this.y = -rubber(o, this.containerH);
        this._show('top', o);
      } else {
        this.y = 0;
      }
    } else if (next > this.max) {
      if (this.overscroll) {
        const o = next - this.max;
        this.y = this.max + rubber(o, this.containerH);
        this._show('bottom', o);
      } else {
        this.y = this.max;
      }
    } else {
      this.y = next;
      this._hide();
    }

    const now = performance.now();
    const dt = Math.max(1, now - this.lastTime);
    this.v = (-dy) / dt * 16.6667;
    this.lastTime = now;

    this._render();
    this._updateThumb();
    e.preventDefault();
  }

  _onUp(e) {
    if (!this.isDown) return;
    this.isDown = false;
    try {
      if (this.vp.releasePointerCapture) this.vp.releasePointerCapture(e.pointerId);
    } catch (err) {
      console.warn('releasePointerCapture failed', err);
    }

    const speed = Math.abs(this.v);
    if (speed > 0.03) {
      const factor = 320;
      let target = this.y + this.v * factor;
      const min = -this.containerH * 0.5;
      const maxb = this.max + this.containerH * 0.5;
      target = clamp(target, min, maxb);
      const dur = clamp(Math.round(180 + Math.min(900, speed * 520)), 180, 1000);
      this._animateTo(target, dur);
    } else {
      if (this.y < 0 || this.y > this.max) this._settle();
    }
  }

  _onWheel(e) {
    if (Math.abs(e.deltaY) < 0.01) return;
    const delta = e.deltaY;
    const next = this.y + delta;

    if (next < 0) {
      if (this.overscroll) {
        const o = -next;
        this.y = -rubber(o, this.containerH);
        this._show('top', o);
      } else {
        this.y = 0;
      }
    } else if (next > this.max) {
      if (this.overscroll) {
        const o = next - this.max;
        this.y = this.max + rubber(o, this.containerH);
        this._show('bottom', o);
      } else {
        this.y = this.max;
      }
    } else {
      this.y = next;
      this._hide();
    }

    this.v = (-delta) / 16.6667;
    this._render();
    this._updateThumb();
    e.preventDefault();
  }

  _onKey(e) {
    if (!e || !e.key) return;
    const k = e.key;
    if (k === 'ArrowDown') { this._nudge(40); e.preventDefault(); }
    else if (k === 'ArrowUp') { this._nudge(-40); e.preventDefault(); }
    else if (k === 'PageDown') { this._nudge(this.containerH * 0.9); e.preventDefault(); }
    else if (k === 'PageUp') { this._nudge(-this.containerH * 0.9); e.preventDefault(); }
    else if (k === 'Home') { this.scrollTo(0); e.preventDefault(); }
    else if (k === 'End') { this.scrollTo(this.max); e.preventDefault(); }
  }

  _nudge(d) {
    this.y = clamp(this.y + d, 0, this.max);
    this.v = 0;
    this._render(true);
    this._updateThumb();
  }

  _animateTo(target, duration) {
    // read current transform safely
    const cs = getComputedStyle(this.content).transform;
    if (cs && cs !== 'none') {
      try {
        const m = new DOMMatrixReadOnly(cs);
        this.y = clamp(-m.m42, -this.containerH * 0.5, this.max + this.containerH * 0.5);
      } catch (err) {
        console.warn('DOMMatrixReadOnly parse failed', err);
      }
    }

    this.content.classList.remove('transitioning');
    this.content.style.transition = 'none';
    this.content.style.transform = `translate3d(0, ${-this.y}px, 0)`;
    // force reflow
    // eslint-disable-next-line no-unused-expressions
    this.content.offsetHeight;

    this._pending = target;
    this.content.classList.add('transitioning');
    this.content.style.transition = `transform ${duration}ms cubic-bezier(0,0,0,1)`;
    this.content.style.transform = `translate3d(0, ${-target}px, 0)`;
  }

  _stopTransition() {
    const cs = getComputedStyle(this.content).transform;
    if (cs && cs !== 'none') {
      try {
        const m = new DOMMatrixReadOnly(cs);
        this.y = clamp(-m.m42, -this.containerH * 0.5, this.max + this.containerH * 0.5);
      } catch (err) {
        console.warn('DOMMatrixReadOnly parse failed', err);
      }
    }
    this.content.classList.remove('transitioning');
    this.content.style.transition = '';
  }

  _settle() {
    const t = clamp(this.y, 0, this.max);
    this._animateTo(t, 360);
  }

  _onTrans(e) {
    if (e && e.propertyName !== 'transform') return;
    this.content.classList.remove('transitioning');
    if (typeof this._pending !== 'undefined') {
      this.y = this._pending;
      this._pending = undefined;
      this._hide();
      this._updateThumb();
    }
  }

  _tick(now) {
    this.lastTime = now;
    // kept for future smoothing; minimal work here
    this.raf = requestAnimationFrame(t => this._tick(t));
  }

  _render(force = false) {
    const ty = Math.round(-this.y * 100) / 100;
    if (!force && this.lastRenderY !== null && Math.abs(this.lastRenderY - ty) < 0.2) return;
    this.lastRenderY = ty;
    // apply transform (note: ty already negative of y)
    this.content.style.transform = `translate3d(0, ${ty}px, 0)`;
    // concise logging for debug (successful events only)
    // console.log('render', ty); // uncomment for heavy debug
  }

  _updateThumb() {
    if (!this.thumb) return;
    const vH = this.containerH;
    const cH = Math.max(1, this.contentH);
    const h = clamp((vH / cH) * vH, 20, vH);
    const maxT = vH - h - 12;
    const r = this.max ? this.y / this.max : 0;
    const top = 6 + clamp(r * maxT, 0, maxT);
    this.thumb.style.height = h + 'px';
    this.thumb.style.transform = `translateY(${top}px)`;
  }

  _show(which, dist) {
    if (!this.overscroll) return;
    const t = clamp(dist / (this.containerH * 0.25), 0, 1);
    if (which === 'top' && this.osTop) this.osTop.style.opacity = (0.25 * t).toString();
    if (which === 'bottom' && this.osBottom) this.osBottom.style.opacity = (0.25 * t).toString();
  }

  _hide() {
    if (this.osTop) this.osTop.style.opacity = '0';
    if (this.osBottom) this.osBottom.style.opacity = '0';
  }

  scrollTo(p, im = false) {
    if (typeof p !== 'number') return;
    const tgt = clamp(p, 0, this.max);
    this.v = 0;
    if (im) {
      this._stopTransition();
      this.y = tgt;
      this._render(true);
      this._updateThumb();
    } else {
      this._animateTo(tgt, 360);
    }
  }

  refresh() {
    this._measure();
  }

  destroy() {
    try {
      this.vp.removeEventListener('pointerdown', this.onDown);
      window.removeEventListener('pointermove', this.onMove);
      window.removeEventListener('pointerup', this.onUp);
      this.vp.removeEventListener('wheel', this.onWheel);
      this.vp.removeEventListener('keydown', this.onKey);
      window.removeEventListener('resize', this.onResize);
      this.content.removeEventListener('transitionend', this.onTrans);
      cancelAnimationFrame(this.raf);
      console.log('Scroller destroyed');
    } catch (err) {
      console.error('Error during destroy', err);
    }
  }
}

// init minimal demo
(function () {
  const vp = $('#vp'), content = $('#content'), thumb = $('#thumb');
  if (!vp) { console.error('#vp not found — aborting init'); return; }
  if (!content) { console.error('#content not found — aborting init'); return; }

  // populate sample content
  const sample = $('#sample');
  if (sample) {
    let s = '';
    for (let i = 1; i <= 60; i++) {
      s += `<h2 style="font-size:16px;font-weight:600;margin-top:18px">Section ${i}</h2><p>サンプル ${i}</p>`;
    }
    sample.innerHTML = s;
    console.log('Sample content injected, length:', 60);
  } else {
    console.warn('#sample element missing — no demo content inserted');
  }

  // create scroller
  let sc = null;
  try {
    sc = new Scroller({ viewport: vp, content: content, thumb: thumb, overscroll: true });
    // expose for debugging if needed
    window.__scroller = sc;
  } catch (err) {
    console.error('Failed to construct Scroller', err);
  }

  // auto-refresh when inner content changes
  const inner = $('#inner');
  if (inner && sc) {
    const mo = new MutationObserver(() => sc && sc.refresh());
    mo.observe(inner, { childList: true, subtree: true, characterData: true });
  }
})();
</script>
</body>
</html>
